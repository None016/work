Эту задачу решить на Python и Pascal и составить блок-схему.
Показать ответ преподавателю.

Имеется набор данных, состоящий из пар положительных целых чисел. Необходимо выбрать из каждой пары ровно одно число так, чтобы сумма всех выбранных чисел оканчивалась на 6 и при этом была минимально возможной. Гарантируется, что искомую сумму получить можно. Программа должна напечатать одно число – минимально возможную сумму, соответствующую условиям задачи.
Входные данные. Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество пар N (1 ≤ N ≤ 100000). Каждая из следующих N строк содержит два натуральных числа, не превышающих 10 000. Пример входного файла:
Пример входного файла:
6
4 7
3 11
1 9
5 4
7 9
5 1
Для указанных входных данных значением искомой суммы должно быть число 26.
В ответе укажите два числа: сначала значение искомой суммы для файла А, затем для файла B.
Решение:
Напишем программу на языке Python.

f=open('aX.txt')

n=int(f.readline())

sm = [0]*10

for i in range(n):
    a = f.readline().split()
    x, y = int(a[0]), int(a[1])

    sm2=[10**9]*10

    for j in range(10):

        r1=sm[j]+x
        r2=sm[j]+y

        sm2[r1%10] = min(r1, sm2[r1%10])
        sm2[r2%10] = min(r2, sm2[r2%10])

    sm=sm2

print(sm[6])
Чтобы проверить на что оканчивается положительное число, можно воспользоваться остатком от деления на 10.
Список sm - это минимальные суммы, для каждого остатка от деления на 10. 
Первая ячейка sm[0] - отвечает за минимальную сумму, которая может получится с остатком от деления на 10 равным нулю, вторая ячейка sm[1] - отвечает за минимальную сумму, которая может получится с остатком от деления на 10 равным единице и т.д.
Переменные x и y - числа очередной пары.
Для каждой пары заводим список sm2. Это минимальные суммы, которые могут получится с учётом конкретной пары для каждого остатка. Эти значения опираются на предыдущие значения sm. 
r1 - это прибавляем число x к сумме каждого остатка. r2 - это прибавляем число y к сумме каждого остатка.
Но числа r1 и r2 могут попасть не в ту же ячейку, которая была использована при получении этих чисел. Числа r1 и r2 могут обладать другими остатками при делении на 10.
В ячейку для конкретного остатка r1%10 мы выбираем минимальное значение из того, что там было, и нового претендента r1. Ведь r1 может "не победить" старое значение. Старые значения могли получится, когда мы это число x прибавляли к другим ячейкам списка sm. Нам нужно среди всех таких вариантов выбрать самое минимальное значение для ячейки конкретного остатка.
С переменной r2 делаем те же действия. Если у r2 будет такой же остаток (r2%10), как и r1, то всё равно в ячейку запишется самое маленькое значение.
В начале кладём в ячейки списка sm2 очень большое число (10**9), т.к. ищём минимальные значения.
Большие числа (10**9) могут перезаписаться в sm, если для какого-то остатка не удалось собрать сумму. Роли они не сыграют, т.к. проиграют всем по минимальности.
Таким образом, и число x, и число y пробуют провзаимодействовать с каждой из 10 ячеек списка sm. Два числа одновременно не смогут попасть в одну ячейку, и попадёт в эту ячейку самое маленькое значение.
Здесь используется именно новый список sm2 для каждой пары. Мы не можем и отталкиваться от списка sm и сразу обновлять этот список.
После окончания "ЦИКЛА с дестью остатками", список sm2 и будет содержать актуальную информацию для каждого остатка. В sm присваиваем sm2.
Шаг за шагом анализируем каждую пару. Раскладывать её "по спектру" на все 10 остатков. 
Чтобы получить ответ, достаточно посмотреть в списке sm ячейку с индексом 6.



